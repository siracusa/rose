=head1 INTRODUCTION

This document provides a step-by-step introduction to the L<Rose::DB::Object> module distribution.  It demonstrates all of the important features using a realistic example database.  This does not replace the actual documentation for each module, however.  The "reference" documentation found in each ".pm" file is still essential, and contains some good examples of its own.

This tutorial provides a gradual introduction to L<Rose::DB::Object>.  It also describes "best practices" for using L<Rose::DB::Object> in the most robust, maintainable manner.  If you're just trying to get a feel for what's possible, you can skip to the end and take a look at the completed example database and associated Perl code.  But I recommend reading the tutorial from start to finish at least once.

The examples will start simple (less abstracted) and then get progressively more complex (more abstracted).  You, the developer, have to decide how much abstraction is appropriate for your particular task.

=head1 CONVENTIONS

The examples in this tutorial will use the fictional C<My::> namespace prefix.  Your code should use whatever namespace you deem appropriate.  Usually, it will be more akin to C<MyCorp::MyProject::> (i.e., your corporation, organization, and/or project).  I've chosen to use C<My::> simply because it's shorter, and will help this tutorial stay within an 80-column width.

For the sake of brevity, the C<use strict> directive and associated "my" declarations have been omitted from the example code.  Needless to say, you should always C<use strict> in your actual code.

Similarly, the traditional "1;" true value used at the end of each ".pm" file has been omitted from the examples.  Don't forget to add this to the end of your actual Perl module files.

=head1 TUTORIAL

=head2 Preface

Before doing anything useful with L<Rose::DB::Object>, it's necessary to create and configure a L<Rose::DB> subclass through which L<Rose::DB::Object>-derived objects will access the database.

To get up to speed quickly with L<Rose::DB>, read the L<Rose::DB::Tutorial> documentation.  The rest of this tutorial will assume the existence of a C<My::DB> class as L<described|Rose::DB::Tutorial/"Multiple data sources using namespaces"> in the L<Rose::DB tutorial|Rose::DB::Tutorial>.

The PostgreSQL ("Postgres") database will be used in the examples in this tutorial, but the features demonstrated will not be specific to that database.  If you are following along with a different database, you may have to adjust the specific syntax used in the SQL table creation statements, but all of the same features should be present in some form.

This tutorial is based on a fictional database schema belonging to a store-like application.  Both the database schema the corresponding Perl classes will evolve over the course of this tutorial.

=head2 Getting started

Let's start with a single table in our fictional store database.

    CREATE TABLE products
    (
      id      SERIAL NOT NULL PRIMARY KEY,
      name    VARCHAR(255) NOT NULL,
      price   DECIMAL(10,2) NOT NULL DEFAULT 0.00,

      UNIQUE(name)
    );

Here's a basic L<Rose::DB::Object> class to front that table:

    package Product;

    use Rose::DB::Object;
    our @ISA = qw(Rose::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->columns(qw(id name price));
    __PACKAGE__->meta->primary_key_columns('id');
    __PACKAGE__->meta->add_unique_key('name');
    __PACKAGE__->meta->initialize;

The steps are simple:

=over 4

=item 1. Inherit from L<Rose::DB::Object>.

=item 2. Name the table.

=item 3. Name the columns.

=item 4. Name the primary key column(s).

=item 5. Add unique keys (if any).

=item 6. Initialize.

=back

Operations 2 through 6 are done through the L<metadata object|Rose::DB::Object::Metadata> associated with this class.  The table must have a primary key, and may have zero or more unique keys.  The primary key and each unique may contain multiple columns.

Of course, L<earlier|/Preface> it was established that L<Rose::DB> needs to be set up for any L<Rose::DB::Object> class to work properly.  To that end, this tutorial assumes the existence of a L<Rose::DB> subclass named L<My::DB> that is set up according to the L<best practices|Rose::DB::Tutorial> of L<Rose::DB>.  We need to make out C<Product> class use L<My::DB>.  Here's one way to do it:

    package Product;

    use My::DB;

    use Rose::DB::Object;
    our @ISA = qw(Rose::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->columns(qw(id name price));
    __PACKAGE__->meta->primary_key_columns('id');
    __PACKAGE__->meta->add_unique_key('name');
    __PACKAGE__->meta->initialize;

    sub init_db { My::DB->new }

Now C<Product> will create a L<My::DB> object when it needs to connect to the database.

=head3 Setting up your own base class

Looking forward, it's likely that all of our L<Rose::DB::Object>-derived classes will want to use L<My::DB> objects when connecting to the database.  It's tedious to repeat this code in all of those classes.  A subclass can provide a single, shared location for that code.

    package My::DB::Object;

    use My::DB;

    use Rose::DB::Object;
    our @ISA = qw(Rose::DB::Object);

    sub init_db { My::DB->new }

Now the C<Product> class can inherit from C<My::DB::Object> instead of inheriting from L<Rose::DB::Object> directly.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->columns(qw(id name price));
    __PACKAGE__->meta->primary_key_columns('id');
    __PACKAGE__->meta->add_unique_key('name');
    __PACKAGE__->meta->initialize;

This use of a subclass is strongly recommended.  You will see this pattern repeated several times in this tutorial.  The creation of seemingly "trivial" subclasses is a cheap and easy way to ensure ease of extensibility later on.  

For example, imagine we want to add a C<clone()> method to all of our database objects.  If they all inherit directly from C<Rose::DB::Object>, that's not easy to do.  But if they all inherit from our C<My::DB::Object>, we can just add the C<clone()> method to that class.

The lesson is simple: when in doubt, subclass.  A few minutes spent now can save you a lot more time down the road.

=head3 Database objects in action

Now that we have our C<Product> class all set up, let's see what we can do with it.

=head4 Get and set column values

By default, each column has a combined accessor/mutator method.  When passed a value, the column value is set and returned.  When called with no arguments, the value is simply returned.

    $p->name('Bike'); # set name
    print $p->name;   # get name

Since L<Rose::DB::Object> inherits from L<Rose::Object>, each object method is also a valid constructor argument.

    $p = Product->new(name => 'Cane', price => 1.99);
    print $p->price; # 1.99

=head4 Load

An object can be loaded based on a primary key.

    $p = Product->new(id => 1); # primary key
    $p->load; # Load the object from the database

An object can also be loaded based on a unique key:

    $p = Product->new(name => 'Sled'); # unique key
    $p->load; # Load the object from the database

If there is no row in the database table with the specified primary or unique key value, the call to L<load()|Rose::DB::Object/load> will fail.  Under the default L<error mode|Rose::DB::Object::Metadata/error_mode>, an exception will be thrown.  To  check whether or not such a row exists, use the C<speculative> parameter.

    $p = Product->new(id => 1);

    unless($p->load(speculative => 1))
    {
      print "No such product with id = 1";
    }

Regardless of the L<error mode|Rose::DB::Object::Metadata/error_mode>, L<load()|Rose::DB::Object/load> will simply return true or false when the  C<speculative> parameter is used.

=head4 Insert

First, let's insert some rows.  To do that, we create objects and then L<save|Rose::DB::Object/save> them.

    $p = Product->new(id => 123, name => 'Widget', price => 4.56);
    $p->save; # Insert the object into the database

The default L<error mode|Rose::DB::Object::Metadata/error_mode> will throw an exception if anything goes wrong during the save, so we don't have to check the return value.

Here's another variation:

    $p = Product->new(name => 'Widget', price => 1.23);
    $p->save;

    print $p->id; # print the auto-generated primary key value

Since the primary key of the C<products> table, C<id>, is a SERIAL column, a new primary key value will be auto-generated if one is not specified.  After the object is saved, we can retrieve the auto-generated value.

=head4 Update

To update a row, simply L<save|Rose::DB::Object/save> an object that has been previously L<load|Rose::DB::Object/load>ed or L<save|Rose::DB::Object/save>d.

    $p1 = Product->new(name => 'Sprocket', price => 9.99);
    $p1->save; # Insert a new object into the database

    $p1->price(12.00);
    $p1->save; # Update the object in the database

    $p2 = Product->new(id => 1);
    $p2->load; # Load an existing object

    $p2->name($p2->name . ' Mark II');
    $p2->save; # Update the object in the database

=head4 Delete

An object can be deleted based on a primary key or a unique key.

    $p = Product->new(id => 1); # primary key
    $p->delete; # Delete the object from the database

An object can also be deleted based on a unique key:

    $p = Product->new(name => 'Sled'); # unique key
    $p->delete; # Delete the object from the database

The L<delete|Rose::DB::Object/delete> method will return true if the row was deleted or did not exist, false otherwise.

It works just as well with objects that have been loaded or saved.

    $p1 = Product->new(name => 'Sprocket', price => 9.99);
    $p1->save;   # Insert a new object into the database
    $p1->delete; # Now delete the object

    $p2 = Product->new(id => 1);
    $p2->load;   # Load an existing object
    $p2->delete; # Now delete the object

=head3 Multiple objects

The examples above show select, insert, update, and delete operations on one object at time based on primary or unique keys.  What about manipulating objects based on other criteria?  What about manipulating multiple objects simultaneously?  Enter L<Rose::DB::Object::Manager>, or just "the manager" for short.

But why a separate class for dealing with multiple objects?  Why not simply add more methods to the object itself?  Say, a C<search()> method to go alongside L<load|Rose::DB::Object/load>, L<save|Rose::DB::Object/save>, L<delete|Rose::DB::Object/delete> and friends?  There are several reasons.

It's somewhat "semantically impure" for the class that represents a single object to also be the class that's used to fetch multiple objects.  It's also important to keep the object method namespace sparsely populated as possible.  Each new object method prevents a column with the same name from using that method name.  L<Rose::DB::Object> tries to keep the list of L<reserved method names|Rose::DB::Object/"RESERVED METHODS"> as small as possible.

Inevitably, classes grow.  It's important for the object manager class to be separate from the object class itself so each class can grow happily in isolation, with no potential clashes.

All of that being said, L<Rose::DB::Object::Manager> does include support for adding manager methods to the object class.  Obviously, this practice is not recommended, but it exists if you really want it.

Anyway, let's see some example.  Making a manager class is simply a matter of inheriting from L<Rose::DB::Object::Manager>, specifying the object class, and then creating a series of appropriately named methods.

    package Product::Manager;

    use Rose::DB::Object::Manager;
    our @ISA = qw(Rose::DB::Object::Manager);

    sub object_class { 'Product' }

    __PACKAGE__->make_manager_methods('products');

The call to L<make_manager_methods()|Rose::DB::Object::Manager/make_manager_methods> creates the following methods:

    get_products
    get_products_iterator
    get_products_count
    delete_products
    update_products

The names are pretty much self-explanatory.  You can read the L<Rose::DB::Object::Manager> documentation for all the gory details.  The important thing to note is that the methods were all named based on the "products" argument to L<make_manager_methods()|Rose::DB::Object::Manager/make_manager_methods>.  You can see how "products" has been incorporated into each of the method names.  Each of these methods is a thin wrapper around the generically-named methods in L<Rose::DB::Object::Manager>.  The wrappers pass the specified object class to the generic methods.

If you decide not to heed my advice and create these methods inside your L<Rose::DB::Object>-derived class directly, then just call L<make_manager_methods()|Rose::DB::Object::Manager/make_manager_methods> from within your object class.

    package Product;

    use Rose::DB::Object::Manager;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);
    ...    
    Rose::DB::Object::Manager->make_manager_methods('products');

This will be the last you see of this technique in this tutorial.  All of the examples will assume that the recommended approach is used instead.

=head4 Fetching objects

The most common task for the manager is fetching multiple objects.  We'll use the C<get_products()> method to do that.  It's based on the L<get_objects()|Rose::DB::Object::Manager/get_objects> method, which takes many parameters.  Most are optional.  In fact, passing no arguments at all will simply fetch every C<Product> object in the database.

    $products = Product::Manager->get_products();

    foreach my $product (@$products)
    {
      print $product->name, "\n";
    }

The return value is a reference to an array in the example above.  A regular array also works.

    @products = Product::Manager->get_products();

Now let's go to the other extreme.

    $products = 
      Product::Manager->get_products(
        query =>
        [
          name => { like => '%Hat' },
          id   => { ge => 7 },
          or   => 
          [
            price => 5.00,
            price => { lt => 10.00 },
          ],
        ],
        sort_by => 'name',
        limit   => 10,
        offset  => 50);

Queries support nested boolean logic and several different kinds of comparison operators.  For a full explanation of all the options, see the L<Rose::DB::Object::Manager> documentation.

The iterator method takes the same kinds of arguments, but returns an iterator that will fetch the objects from the database one at a time.

    $iterator = Product::Manager->get_products_iterator(...);

    while($product = $iterator->next)
    {
      print $product->id, ' ', $product->name, "\n";

      $iterator->finish  if(...);  # exit early?
    }

    print $iterator->total; # total iterated over

=head4 Counting objects

Counting objects is straightforward.  The C<get_products_count()> method takes the same same kinds of arguments as C<get_products()> and C<get_products_iterator()>.  (Noticing a pattern here?)  I returns the count.

    $num_cheap_products = 
      Product::Manager->get_products_count(
        query => [ price => { lt => 1.00 } ]);

=head4 Deleting objects

The C<delete_products()> method accepts the same kinds of C<query> arguments as the manager methods described above, only it uses the parameter name C<where> instead.

    $num_rows_deleted =
      Product::Manager->delete_products(
        where =>
        [
          id    => { ne => 123 },
          name  => { like => 'Wax%' },
        ]);

=head4 Updating objects

The C<update_products()> method accepts the same kinds of arguments as the C<delete_products()> method, plus a C<set> parameter to specify the actual update information.

    $num_rows_updated =
      Product::Manager->update_products(
        set =>
        {
          price => 5.00,
        },
        where =>
        [
          price => 4.99,
          id    => { gt => 100 },
        ]);

=head3 The end of the beginning

This section covers the I<bare minimum> usage and functionality of the L<Rose::DB::Object> module distribution.  Using these features alone, you can automate the basic CRUD operations (Create, Retrieve, Update, and Delete) for single or multiple objects.  But it's almost a shame to stop at this point.  There's a lot more that L<Rose::DB::Object> can do for you.  The "sweet spot" of effort vs. results is much farther along the curve.

In the next section, we will expand upon our C<Product> class and tap more of L<Rose::DB::Object>'s features.

=head2 Your first "real" class

Let's imagine that the C<products> table has expanded.  It now looks like this.

    CREATE TABLE products
    (
      id      SERIAL NOT NULL PRIMARY KEY,
      name    VARCHAR(255) NOT NULL,
      price   DECIMAL(10,2) NOT NULL DEFAULT 0.00,

      status  VARCHAR(128) NOT NULL DEFAULT 'inactive' 
                CHECK(status IN ('inactive', 'active', 'defunct')),

      date_created  TIMESTAMP NOT NULL DEFAULT NOW(),
      release_date  TIMESTAMP,

      UNIQUE(name)
    );

We could do a straightforward expansion of the C<Product> class as designed in the L<previous section|/"Getting started">.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->columns(
      qw(id name price status date_created release_date));
    __PACKAGE__->meta->primary_key_columns('id');
    __PACKAGE__->meta->add_unique_key('name');
    __PACKAGE__->meta->initialize;

But now we're faced with a few problems.  First, while the C<status> column only accepts a few pre-defined values, our C<Product> objects will gladly accept any value.  But maybe that's okay because a exception will be thrown when the object is saved anyway.

The date/time fields are more troubling.  What is the format of a valid value for a TIMESTAMP column in Postgres?  Consulting the documentation will yield the answer, I suppose.  But now all the code that uses C<Product> objects has to be sure to format the C<date_created> and C<release_date> values accordingly.  That's even more difficult if some of those values come from external sources, such as a web form.

Worse, what if we decide to change databases in the future?  We'd have to hunt down every single place where a C<date_created> or C<release_date> value is set and then modify the formatting to match whatever format the new database wants.  Oh, and we'll have to look that up too.  Blah.

Finally, what about all those default values?  The C<price> column already had a default value, but now two more columns also have defaults.  True, the database will take care of this when a row is inserted, but now the Perl object is diverging more and more from the database representation.

Let's solve all of these problems.  If we more accurately describe the columns, L<Rose::DB::Object> will do the rest.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->table('products');

    __PACKAGE__->meta->columns
    (
      id   => { type => 'serial', primary_key => 1, not_null => 1 },
      name => { type => 'varchar', length => 255, not_null => 1 },

      price => 
      {
        type      => 'decimal',
        precision => 10,
        scale     => 2,
        not_null  => 1,
        default   => 0.00 
      },

      status => 
      {
        type     => 'varchar', 
        length   => 128,
        not_null => 1, 
        default  => 'inactive', 
        check_in => [ 'inactive', 'active', 'defunct' ]
      },

      date_created => { type => 'timestamp', not_null => 1 },
      release_date => { type => 'timestamp' },
    );

    __PACKAGE__->meta->add_unique_key('name');
    __PACKAGE__->meta->initialize;

Before examining what new functionality this new class gives us, there are a few things to note about the definition.  First, the primary key is no longer specified with the L<primary_key_columns()|Rose::DB::Object::Metadata/primary_key_columns> method.  Instead, the C<id> column has its C<primary_key> attribute set to a true value in its description.

Second, the C<date_created> doesn't have a default value listed in the column description, despite the fact that the database table definition does have a default value of C<NOW()>.  This is intentional.  In the case of "creation date" columns like this, it's usually better to let the database fill in the value as close as possible to the very moment the row is created.  On the other hand, this will mean that the Perl object will have an undefined value for that column until/unless it is loaded from the database.  It's a trade-off, but I've made my choice this time.

Let's see the new C<Product> class in action. The defaults work as expected.

    $p = Product->new;

    print $p->status; # 'inactive'
    print $p->price;  # 0.00

The C<status> method now restricts its input, throwing an exception if the input is invalid.

    $p->status('nonesuch'); # Boom!  Invalid status: 'nonesuch'

The timestamp columns now accept any value that L<Rose::DateTime::Util>'s L<parse_date()|Rose::DateTime::Util/parse_date> method can understand.

    $p->release_date('2005-01-22 18:00:57');
    $p->release_date('12/24/1980 10am');

See the L<Rose::DateTime::Util|Rose::DateTime::Util/parse_date> documentation for a full list of acceptable formats.

Internally, date/time information is stored in L<DateTime> objects.

    $dt = $p->release_date; # DateTime object

Since  L<DateTime> objects can be modified in-place, doing a formerly thorny task like date math is now trivial.

    $p->release_date->add(days => 1);

The C<release_date()> method also accepts a L<DateTime> object as an input, of course:

    $p->release_date(DateTime->new(...));

There are even a few convenience functions triggered by passing a name/value pair.

    # Thursday, December 25th 1980 at 10:00:00 AM
    print $p->release_date(format => '%A, %B %E %Y at %t');

    # Clone the DateTime object, truncate the clone, and return it
    $month_start = $p->release_date(truncate => 'month');

    print $month_start->strftime('%Y-%m-%d'); # 1980-12-01

The upshot is that you no longer have to be concerned about the details of the date/time format(s) understood by the underlying database.  You're also free to use L<DateTime> objects as a convenient interchange format in your code.

=head2 Auto-initialization and the convention manager

The C<Product> class set up in the previous section is useful, but it also takes significantly more typing to set up.  Over the long term, it's still a clear win.  On the other hand, a lot of the details in the column descriptions are already known by the database: column types, default values, maximum lengths, etc.  It would be handy if we could ask the database for this information instead of looking it up and typing it in manually.

This process of interrogating the database in order to extract metadata is called "auto-initialization."  There's an L<entire section|Rose::DB::Object::Metadata/"AUTO-INITIALIZATION"> of the L<Rose::DB::Object::Metadata> documentation dedicated to the topic.  The executive summary is that auto-initialization saves work in the short-run, but at the cost of some long-term costs.  Read the L<friendly manual|Rose::DB::Object::Metadata/"AUTO-INITIALIZATION"> for the details.  For the purposes of this tutorial, I will simply demonstrate the features, culminating in the suggested best practice.

Let's start by applying auto-initialization to the C<Product> class.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->auto_initialize;

Believe it or not, that class is equivalent to the previous incarnation, right down to the details of the columns and the unique key.  As long as the table is specified, L<Rose::DB::Object> will dig all the rest of the information out of the database.  Handy!

In fact, that class can be shortened even further with the help of the L<convention manager|Rose::DB::Object::ConventionManager>.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->auto_initialize;

Now even the table is left unspecified.  How does L<Rose::DB::Object> know what to do in this case?  Why, by convention, of course.  The default convention manager dictates that class names are singular and title-cased and their corresponding table names are lowercase and plural.  Thus, the omitted table name in the C<Product> class is, by convention, assumed to be named "products".

Like auto-initialization, convention managers are handy, but may also present some maintenance issues.  I tend to favor a more explicitly approach, but I can also imagine scenarios where the convention manager is a good fit.  Keep in mind that customized convention managers are possible, allowing individual organizations or projects to define their own conventions.  You can read all about it in the L<Rose::DB::Object::ConventionManager> documentation.

Anyway, back to auto-initialization.  Yes, L<auto_initialize()|Rose::DB::Object::Metadata/auto_initialize> will dig out all sorts of interesting and important information for you.  Unfortunately, it will dig that information out I<every single time the class is loaded>.  Worse, this class will fail to load at all if a database connection is not immediately available.

Auto-initialization seems like something that is best done only once, with the results being saved in a more conventional form.  That's just what L<Rose::DB::Object::Metadata>'s L<code generation|Rose::DB::Object::Metadata/"Code Generation"> functions are designed to do.  The C<perl_*> family of methods can generate snippets of Perl code, or even entire classes, based on the results of the auto-initialization process.  They'll even honor some basic code formatting directives.

    package Product;

    use My::DB::Object;
    our @ISA = qw(My::DB::Object);

    __PACKAGE__->meta->table('products');
    __PACKAGE__->meta->auto_initialize;

    print __PACKAGE__->meta->perl_class_definition(indent => 2,
                                                   braces => 'bsd');

Here's the output of that print statement.  A few long lines were manually wrapped, but it's otherwise unmodified.

  package Product;

  use strict;

  use My::DB::Object
  our @ISA = qw(My::DB::Object);

  __PACKAGE__->meta->table('products');

  __PACKAGE__->meta->columns
  (
    id           => { type => 'integer', not_null => 1 },
    name         => { type => 'varchar', length => 255, not_null => 1 },
    price        => { type => 'numeric', default => '0.00', 
                      not_null => 1, precision => 2, scale => 10 },
    status       => { type => 'varchar', default => 'inactive', 
                      length => 128, not_null => 1 },
    date_created => { type => 'timestamp', not_null => 1 },
    release_date => { type => 'timestamp' },
  );

  __PACKAGE__->meta->primary_key_columns([ 'id' ]);

  __PACKAGE__->meta->add_unique_keys([ 'name' ]);

  __PACKAGE__->meta->initialize;

  1;

Copy and paste that output back into the "Product.pm" file and you're in business.

The door is open to further automation through scripts that call the methods demonstrated above.  Although it's my inclination to work towards a static, explicit type of class definition, the tools are there for those who prefer a more dynamic approach.

=head2 Foreign keys









=head1 DEVELOPMENT POLICY

The L<Rose development policy|Rose/"DEVELOPMENT POLICY"> applies to this, and all C<Rose::*> modules.  Please install L<Rose> from CPAN and then run "C<perldoc Rose>" for more information.

=head1 SUPPORT

Any L<Rose::DB::Objects> questions or problems can be posted to the L<Rose::DB::Object> mailing list.  To subscribe to the list or view the archives, go here:

L<http://lists.sourceforge.net/lists/listinfo/rose-db-object>

Although the mailing list is the preferred support mechanism, you can also email the author (see below) or file bugs using the CPAN bug tracking system:

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Rose-DB-Object>

=head1 AUTHOR

John C. Siracusa (siracusa@mindspring.com)

=head1 COPYRIGHT

Copyright (c) 2005 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
